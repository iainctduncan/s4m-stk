
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Tutorial 1 - Multi-Track Step Sequencer &#8212; Scheme for Max Sequencing Toolkit 1.0 documentation</title>
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Appendix: Performance, timing accuracy, and Max settings" href="performance.html" />
    <link rel="prev" title="Introduction" href="tutorials-intro.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="tutorial-1-multi-track-step-sequencer">
<h1>Tutorial 1 - Multi-Track Step Sequencer<a class="headerlink" href="#tutorial-1-multi-track-step-sequencer" title="Permalink to this headline">¶</a></h1>
<p>In this first tutorial, we’re going to make a one-track sequencer that plays from a
grid of data at a constant rate. By the end of the tutorial, you’ll have the tools
for building a step-sequencer that you can work with using Scheme code, Max widgets,
or midi input, with on-screen displays. This tutorial covers enough of each
of these areas (engine, controller, display) to give you the building blocks
to make a full featured step sequencer customized to your needs and workflow.
This is the first publication in the Scheme For Max Sequencer Toolkit, and
subsequent releases will include a library of components you can build on to
make a complete, professional production ready live sequencing environment,
with performance and accuracy suitable for studio or stage.</p>
<p>In this first tutorial, all functions and definitions will be global. This
is convenient when prototyping as it makes it easy to redefine them on the fly -
you can even send new functions to s4m <em>while the sequencer is running</em>!
In a subsequent tutorial we’ll put our code into an object-like function that acts
as a module and namespace so that we can instantiate more than one at a time.</p>
<div class="section" id="step-1-clocking-options">
<h2>Step 1 - Clocking options<a class="headerlink" href="#step-1-clocking-options" title="Permalink to this headline">¶</a></h2>
<p>To begin, we need a function that runs on every step and triggers our
events. We’ll call this <strong>run-step</strong>.
We have several options for clocking our sequencer to call run-step.</p>
<p>The simplest option is to just hook it up to a metronome, or any event triggering
code, and send the <strong>run-step</strong> message to s4m inlet 0. You could even use
this to trigger the events off an audio rate phaser if you wanted to, but in recent
versions of Max this isn’t necessary anymore as the scheduler can run with sample
accurate timing (depending on your settings and audio buffers).</p>
<p>The second simplest is to do the same kind of thing, but use Scheme to register
the clock call with either <strong>clock-ms</strong> or <strong>clock-ticks</strong>. This is technically
the most efficient under the hood, but that’s not going to matter unless you have
a large number of sequencers running very frequently. If we use <strong>clock-ms</strong>, our
listener function will fire every X ms, no matter what the global transport is doing.
With <strong>clock-ticks</strong>, the listener will only fire if the global transport is running.
For both the clock functions, there is only one master clock (each), so you would
need to call other sequencers from the same master clocking function. Another
reason you might want this approach is if you plan on having other functions running
off very small time quantiles - in this case you could register a single tick listener
and call run step every so often. A <strong>clock-ticks</strong> listener function should take one
argument, and is passed the current tick. A <strong>clock-ms</strong> listener should take no arguments
- it can always get the current time using a call to <strong>time</strong>.</p>
<p>Now for reasons of thread safety, s4m doesn’t (currently) allow you to put scheduling calls
into code that is run on boot of the s4m object. So we will put the code to register
our clock listener into an <strong>init</strong> function, and we’ll call that with a message
object that sends ‘init’ to s4m inlet 0:</p>
<div class="highlight-scm notranslate"><div class="highlight"><pre><span></span><span class="c1">; our global clock listener that will fire on every tick</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">tick-listener</span> <span class="nv">ticks</span><span class="p">)</span>
  <span class="c1">; use modulo to determine if this is a 16th note boundary</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="mi">0</span> <span class="p">(</span><span class="nb">modulo </span><span class="nv">ticks</span> <span class="mi">120</span><span class="p">))</span>
    <span class="p">(</span><span class="nf">run-step</span><span class="p">)))</span>

<span class="c1">; register the above to run every single tick</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">init-clock</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">post</span> <span class="s">&quot;(init) - registering clock listener&quot;</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">clock-ticks</span> <span class="mi">1</span> <span class="nv">tick-listener</span><span class="p">))</span>
</pre></div>
</div>
<p>If we don’t plan on doing anything outside of step boundaries, the below will be
less cpu costly, as it only runs once a sixteenth:</p>
<div class="highlight-scm notranslate"><div class="highlight"><pre><span></span><span class="c1">; make an anonymous function that calls run-step</span>
<span class="c1">; and register it for every 120 ticks</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">init</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">clock-ticks</span> <span class="mi">120</span> <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">ticks</span><span class="p">)</span> <span class="p">(</span><span class="nf">run-step</span><span class="p">))))</span>
</pre></div>
</div>
<p>On the other hand, maybe we want to be able to run multiple sequencers,
and have the flexibility to stop and start them independent of the transport
controls. In this case, we can use <em>self-scheduling</em>, which is also
sometimes called <em>temporal recursion</em>. On every call to run-step, we put
the <em>next</em> call to run-step on the scheduler. This requires us to build
in a way to stop the self-scheduling, which we’ll do with a variable
that we check on each call:</p>
<div class="highlight-scm notranslate"><div class="highlight"><pre><span></span><span class="c1">; version 1-1, run for ever, posting to the console</span>

<span class="c1">; a global boolean variable to control whether we keep playing</span>
<span class="p">(</span><span class="k">define </span><span class="nv">playing</span> <span class="no">#f</span><span class="p">)</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">run-step</span><span class="p">)</span>
  <span class="s">&quot;function that executes on every step, and schedules the next step&quot;</span>
  <span class="p">(</span><span class="nf">post</span> <span class="s">&quot;(run-step)&quot;</span><span class="p">)</span>
  <span class="c1">; if the playing is #true, schedule next pass after 480 ticks</span>
  <span class="p">(</span><span class="k">if </span><span class="nv">playing</span>
    <span class="p">(</span><span class="nf">delay-t</span> <span class="mi">480</span> <span class="nv">run-step</span><span class="p">)))</span>
</pre></div>
</div>
<p>We can now run our sequencer by setting <strong>playing</strong> to <strong>#t</strong>, and calling
the run-step function. And we can stop it by changing the
<strong>playing</strong> variable to <strong>#f</strong>. Note that it uses the current global
transport <strong>tempo</strong> to determine how long ticks should be, but the
transport does not have to be playing anymore for our sequencer to run.
For the rest of the tutorial, we’ll use this clocking technique as its
the most flexible and easiest to prototype with.</p>
<div class="highlight-scm notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">set! </span><span class="nv">playing</span> <span class="no">#t</span><span class="p">)</span>
<span class="p">(</span><span class="nf">run-step</span><span class="p">)</span>

<span class="nv">s4m&gt;</span><span class="p">(</span><span class="nf">run-step</span><span class="p">)</span>
<span class="nv">s4m&gt;</span><span class="p">(</span><span class="nf">run-step</span><span class="p">)</span>
<span class="nv">s4m&gt;</span><span class="p">(</span><span class="nf">run-step</span><span class="p">)</span>
<span class="o">....</span>

<span class="p">(</span><span class="k">set! </span><span class="nv">playing</span> <span class="no">#f</span><span class="p">)</span>
</pre></div>
</div>
<p>The example code for step-seq-1-1.scm and step-seq-1-1.maxpat has
both of these approaches for you to try out, but after this example,
we’ll just be using self-scheduling so that we don’t have to muck
about with the transport.</p>
</div>
<div class="section" id="step-2-transport-controls">
<h2>Step 2 - Transport controls<a class="headerlink" href="#step-2-transport-controls" title="Permalink to this headline">¶</a></h2>
<p>You might notice that when you set playing to #f, you get an extra event,
because the next pass of run-step is already scheduled. Let’s clean that up a bit by putting
in functions for stopping and starting, and having the stop function cancel
the scheduled next function with the <strong>cancel-delay</strong> function. This means
we need to save the callback handle returned by <strong>delay-t</strong>, so we’ll add another
state variable. We’ll make it possible to change the delay time by putting that in a variable too.
This means the length of a tick is still determined by our global transport tempo,
but the number of ticks per step is dynamic.</p>
<div class="highlight-scm notranslate"><div class="highlight"><pre><span></span><span class="c1">; version 1-2, run with play and stop functions</span>

<span class="c1">; new global to hold the callback handle from the most recent scheduled event</span>
<span class="p">(</span><span class="k">define </span><span class="nv">cb-handle</span> <span class="no">#f</span><span class="p">)</span>
<span class="c1">; duration of a step in ticks, used for the delat time</span>
<span class="p">(</span><span class="k">define </span><span class="nv">ticks-per-step</span> <span class="mi">480</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="nv">playing</span> <span class="no">#f</span><span class="p">)</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">run-step</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">post</span> <span class="s">&quot;(run-step)&quot;</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if </span><span class="nv">playing</span>
    <span class="c1">; this time we save the callback handle</span>
    <span class="p">(</span><span class="k">set! </span><span class="nv">cb-handle</span> <span class="p">(</span><span class="nf">delay-t</span> <span class="nv">ticks-per-step</span> <span class="nv">run-step</span><span class="p">))))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">play</span><span class="p">)</span>
  <span class="s">&quot;start the sequencer by setting playing and calling first step&quot;</span>
  <span class="p">(</span><span class="nf">post</span> <span class="s">&quot;(play) - starting playback&quot;</span><span class="p">)</span>
  <span class="p">(</span><span class="k">set! </span><span class="nv">playing</span> <span class="no">#t</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">run-step</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">stop</span><span class="p">)</span>
  <span class="s">&quot;stop the sequencer by clearing playing and cancelling the next event&quot;</span>
  <span class="p">(</span><span class="nf">post</span> <span class="s">&quot;(stop) - stopping playback&quot;</span><span class="p">)</span>
  <span class="p">(</span><span class="k">set! </span><span class="nv">playing</span> <span class="no">#f</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">cancel-delay</span> <span class="nv">cb-handle</span><span class="p">))</span>
</pre></div>
</div>
<p>Now we can start and stop the sequencer and change its time-base. If we want
to start and stop from Max GUI objects, all we need to do is make some message
objects with “play” and “stop”, and send those into inlet 0 of the s4m object.
This will call the play and stop functions, as it gets interpreted
in s4m as <strong>(play)</strong> and <strong>(stop)</strong>.</p>
</div>
<div class="section" id="step-3-musical-data-and-output">
<h2>Step 3 - Musical data and output<a class="headerlink" href="#step-3-musical-data-and-output" title="Permalink to this headline">¶</a></h2>
<p>So far, so good! Now we need
some data to play-over, and we’d like our sequencer to loop over the data.
This means we need a container for our sequence data, and some kind of step counter. We’re going
to use a <strong>vector</strong> to hold a series of pitches, and add variables to keep track
of where we are and how long our loop should be. We will use a vector rather than
a list because we’ll be doing random access into the data, for which a vector performs
much better.</p>
<p>We’ll also add a function for playing a note. It will output a list of <strong>(note, velocity, duration)</strong>,
which is the format expected by the <strong>makenote</strong> object. For now, our velocity
and duration will be static values.</p>
<p>Finally, we need to update the run-step function so that it will look up data for the current step,
play a note, and increment the step counter for the next pass before re-scheduling.</p>
<div class="highlight-scm notranslate"><div class="highlight"><pre><span></span><span class="c1">; version 1-3, loop over some data, sending output for midi notes</span>

<span class="p">(</span><span class="k">define </span><span class="nv">cb-handle</span> <span class="no">#f</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="nv">playing</span> <span class="no">#f</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="nv">ticks-per-step</span> <span class="mi">480</span><span class="p">)</span>
<span class="c1">; new vars for current step number and the loop length</span>
<span class="p">(</span><span class="k">define </span><span class="nv">curr-step</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="nv">loop-len</span> <span class="mi">4</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="nv">loop-top</span> <span class="mi">0</span><span class="p">)</span>

<span class="c1">; data variable is a vector of midi notes</span>
<span class="p">(</span><span class="k">define </span><span class="nv">seq-data</span> <span class="p">(</span><span class="nb">vector </span><span class="mi">60</span> <span class="mi">64</span> <span class="mi">67</span> <span class="mi">64</span><span class="p">))</span>

<span class="c1">; new note playing function</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">play-note</span> <span class="nv">note-num</span><span class="p">)</span>
  <span class="s">&quot;play a note by outputing a note events data as a list&quot;</span>
  <span class="p">(</span><span class="nf">post</span> <span class="s">&quot;(play-note) note-num:&quot;</span> <span class="nv">note-num</span><span class="p">)</span>
  <span class="c1">; output a list through outlet 0, with velocity 90, duration 250ms</span>
  <span class="p">(</span><span class="nf">out</span> <span class="mi">0</span> <span class="p">(</span><span class="nb">list </span><span class="nv">note-num</span> <span class="mi">90</span> <span class="mi">250</span><span class="p">)))</span>

<span class="c1">; adding data lookup and playback</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">run-step</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">post</span> <span class="s">&quot;(run-step)&quot;</span><span class="p">)</span>
  <span class="c1">; (seq-data curr-step) returns data at index curr-step in vector</span>
  <span class="p">(</span><span class="nf">play-note</span> <span class="p">(</span><span class="nf">seq-data</span> <span class="nv">curr-step</span><span class="p">))</span>

  <span class="c1">; increment or reset the step counter for the next pass</span>
  <span class="p">(</span><span class="k">set! </span><span class="nv">curr-step</span>
    <span class="c1">; if the step counter is less than loop-len - 1, increment</span>
    <span class="c1">; otherwise, set it to zero</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt; </span><span class="nv">curr-step</span> <span class="p">(</span><span class="nb">- </span><span class="nv">loop-len</span> <span class="mi">1</span><span class="p">))</span>
      <span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="nv">curr-step</span><span class="p">)</span>
      <span class="mi">0</span><span class="p">))</span>

  <span class="p">(</span><span class="k">if </span><span class="nv">playing</span>
    <span class="p">(</span><span class="k">set! </span><span class="nv">cb-handle</span> <span class="p">(</span><span class="nf">delay-t</span> <span class="nv">ticks-per-step</span> <span class="nv">run-step</span><span class="p">)))</span>
<span class="p">)</span><span class="c1">; end run-step</span>

<span class="c1">; update the stop function to reset the counter</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">stop</span><span class="p">)</span>
  <span class="s">&quot;stop the sequencer by clearing playing and cancelling the next event&quot;</span>
  <span class="p">(</span><span class="nf">post</span> <span class="s">&quot;(stop) - stopping playback&quot;</span><span class="p">)</span>
  <span class="p">(</span><span class="k">set! </span><span class="nv">playing</span> <span class="no">#f</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">cancel-delay</span> <span class="nv">cb-handle</span><span class="p">)</span>
  <span class="c1">; reset step counter</span>
  <span class="p">(</span><span class="k">set! </span><span class="nv">curr-step</span> <span class="mi">0</span><span class="p">))</span>

<span class="c1">; play function has not changed.</span>
</pre></div>
</div>
<p>To get our output playing notes, we need to make a Max patcher with an unpack, makenote,
and some objects for midiout (or vst instrument).  See the tutorial 1 patcher folder for
the Max code. If you want to try a free vst-instrument, I
recommend the Podolski from U-He, my favourite soft-synth
developer!</p>
</div>
<div class="section" id="step-4-multi-dimensional-data-and-writing-to-data">
<h2>Step 4 - Multi-dimensional data, and writing to data<a class="headerlink" href="#step-4-multi-dimensional-data-and-writing-to-data" title="Permalink to this headline">¶</a></h2>
<p>Our sequencer plays, but only sequences one element - the pitch. We’ll change
our data now to be a multi-dimensional vector, where each data point in the top
dimension is another vector with <strong>num-params</strong> data points. This will let us
sequence some arbitrary number of parameters for each note event. For simplicy,
we’ll start with four: <strong>gate</strong>, <strong>duration</strong>, <strong>pitch</strong>, and <strong>velocity</strong>. By
making a gate param, we can turn on and off steps without erasing their content.
The new version of <strong>play-note</strong> uses these data params, only outputing a note
if the gate is on.</p>
<p>We will also add functions to write to the sequence. We’ll have one for
writing only one parameter, one for writing all the params from a given step,
and one for updating a range of steps in the sequence data. For the purpose of the tutorial,
there will be no checking on the ranges, but you could add this easily if you want it.</p>
<p>There is one tricky bit of Scheme code worth mentioning. The for-each function
gets passed a function to call over a sequence of values, and the sequence of values.
If we pass in more than one sequence of values (as argument 3, for example), the
iterator function will get called with one value from each sequence as an argument, until the
shorter sequence is exhausted. We’re going to use that to enumerate through
data. Also, you’ll note our lambda functions passed to for-each are <em>closures</em>.
They use the values from their arguments, but also the arguments to the containing
function as static values.</p>
<div class="highlight-scm notranslate"><div class="highlight"><pre><span></span><span class="c1">; change to 16th notes per step</span>
<span class="p">(</span><span class="k">define </span><span class="nv">ticks-per-step</span> <span class="mi">120</span><span class="p">)</span>
<span class="c1">; max number of steps in our sequence data</span>
<span class="p">(</span><span class="k">define </span><span class="nv">num-steps</span> <span class="mi">16</span><span class="p">)</span>
<span class="c1">; number of note params: gate, dur, pitch, vel</span>
<span class="p">(</span><span class="k">define </span><span class="nv">num-params</span> <span class="mi">4</span><span class="p">)</span>

<span class="c1">; make a 2D vector using the above sizes, initialized to 0</span>
<span class="c1">; make-vector arg 1 is a list of dimension sizes</span>
<span class="p">(</span><span class="k">define </span><span class="nv">seq-data</span> <span class="p">(</span><span class="nb">make-vector </span><span class="p">(</span><span class="nb">list </span><span class="nv">num-steps</span> <span class="nv">num-params</span><span class="p">)</span> <span class="mi">0</span><span class="p">))</span>

<span class="c1">; new play-note that uses all four params</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">play-note</span> <span class="nv">params</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">post</span> <span class="s">&quot;(play-note)&quot;</span> <span class="nv">params</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">gate</span> <span class="p">(</span><span class="nf">params</span> <span class="mi">0</span><span class="p">))</span>
        <span class="p">(</span><span class="nf">dur</span>  <span class="p">(</span><span class="nf">params</span> <span class="mi">1</span><span class="p">))</span>
        <span class="p">(</span><span class="nf">note</span> <span class="p">(</span><span class="nf">params</span> <span class="mi">2</span><span class="p">))</span>
        <span class="p">(</span><span class="nf">vel</span>  <span class="p">(</span><span class="nf">params</span> <span class="mi">3</span><span class="p">)))</span>
    <span class="c1">; notes only go out if the gate is on</span>
    <span class="p">(</span><span class="k">if </span><span class="nv">gate</span>
      <span class="c1">; output in the format expected by Max makenote object</span>
      <span class="p">(</span><span class="nf">out</span> <span class="mi">0</span> <span class="p">(</span><span class="nb">list </span><span class="nv">note</span> <span class="nv">vel</span> <span class="nv">dur</span><span class="p">)))))</span>

<span class="c1">; new functions to write to the data</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">update-step-param</span> <span class="nv">step</span> <span class="nv">param</span> <span class="nv">value</span><span class="p">)</span>
  <span class="s">&quot;update one step and one paramater in the sequence data&quot;</span>
  <span class="p">(</span><span class="k">set! </span><span class="p">(</span><span class="nf">seq-data</span> <span class="nv">step</span> <span class="nv">param</span><span class="p">)</span> <span class="nv">value</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">update-step</span> <span class="nv">step</span> <span class="nv">pvals</span><span class="p">)</span>
  <span class="s">&quot;update all params for a step from a sequence of pvals&quot;</span>
  <span class="p">(</span><span class="nf">for-each</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">param</span> <span class="nv">value</span><span class="p">)(</span><span class="nf">update-step-param</span> <span class="nv">step</span> <span class="nv">param</span> <span class="nv">value</span><span class="p">))</span>
    <span class="c1">; iterate through a sequence of integers and the pvals in parallel</span>
    <span class="p">(</span><span class="nf">range</span> <span class="mi">0</span> <span class="p">(</span><span class="nb">length </span><span class="nv">pvals</span><span class="p">))</span> <span class="nv">pvals</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">update-seq</span> <span class="nv">starting-step</span> <span class="nv">pvals-list</span><span class="p">)</span>
  <span class="s">&quot;write multiple notes into the sequence data starting at starting-step&quot;</span>
  <span class="p">(</span><span class="nf">for-each</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">step</span> <span class="nv">pvals</span><span class="p">)</span> <span class="p">(</span><span class="nf">update-step</span> <span class="nv">step</span> <span class="nv">pvals</span><span class="p">))</span>
    <span class="p">(</span><span class="nf">range</span> <span class="nv">starting-step</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">starting-step</span> <span class="p">(</span><span class="nb">length </span><span class="nv">pvals-list</span><span class="p">)))</span>
    <span class="nv">pvals-list</span><span class="p">))</span>
</pre></div>
</div>
<p>We can test these data handling functions in the repl before using them
in the sequencer. If we want to make gui elements in Max to update our sequence
data, we just need some message objects with the appropriate arguments. For example,
to update the gate param for to mute step 0, we want our object to send the following
message into the s4m object <strong>update-step-param 0 0 0</strong>. We do this easily in
Max using the <strong>$</strong> arguments in message boxes. The step-seq-1-4.maxpat patcher
shows various examples of this, with some sliders hooked up to write to velocity,
a number box changing the loop length, and three number boxes set up to write
any of the 4 params to any step.</p>
<p>We’ll also add a function to seed our sequencer data with some musical input for testing:</p>
<div class="highlight-scm notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">seed-data</span><span class="p">)</span>
  <span class="s">&quot;seed our sequencer with 16 steps of data&quot;</span>
  <span class="p">(</span><span class="nf">post</span> <span class="s">&quot;seeding test data&quot;</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">update-seq</span> <span class="mi">0</span> <span class="p">(</span><span class="nf">list</span>
    <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">110</span> <span class="mi">60</span> <span class="mi">90</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">110</span> <span class="mi">67</span> <span class="mi">90</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">110</span> <span class="mi">63</span> <span class="mi">90</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">110</span> <span class="mi">70</span> <span class="mi">90</span><span class="p">)</span>
    <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">110</span> <span class="mi">72</span> <span class="mi">90</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">110</span> <span class="mi">67</span> <span class="mi">90</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">110</span> <span class="mi">70</span> <span class="mi">90</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">110</span> <span class="mi">63</span> <span class="mi">90</span><span class="p">)</span>
    <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">110</span> <span class="mi">60</span> <span class="mi">90</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">110</span> <span class="mi">67</span> <span class="mi">90</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">110</span> <span class="mi">63</span> <span class="mi">90</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">110</span> <span class="mi">70</span> <span class="mi">90</span><span class="p">)</span>
    <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">110</span> <span class="mi">72</span> <span class="mi">90</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">110</span> <span class="mi">67</span> <span class="mi">90</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">110</span> <span class="mi">70</span> <span class="mi">90</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">110</span> <span class="mi">63</span> <span class="mi">90</span><span class="p">)</span>
  <span class="p">)))</span>
</pre></div>
</div>
<p>If you load up the step-seq-1-4.maxpat file, you can now use the <strong>seed</strong> button
to run this loop and hear real music! Don’t forget that if you click the <strong>reset</strong>
button to reset the interpreter, you will need to reseed the data again, and also
to reclick scan if you want to be able to send messages from Scheme to GUI elements.
In a larger system we would probably make an init function to do this for us.</p>
<p><em>Question, should there be one in this??</em></p>
</div>
<div class="section" id="step-5-loop-controls">
<h2>Step 5 - Loop controls<a class="headerlink" href="#step-5-loop-controls" title="Permalink to this headline">¶</a></h2>
<p>One of things that makes step sequencers fun is changing the loop settings on the fly
to create happy accidents, so let’s add some looping controls.
We’ll add the ability to change the loop length as well as where in the sequence
the loop starts, and we’ll add in some protection to ensure that instead of
crashing if we try to read past the end of the sequence data, the read function
wraps around the sequence. And we’ll add a playback rate control to allow
us to speed up or slow down the entire sequencer without changing any of the data.</p>
<p>To do this, we’ll add a few new variables: <strong>loop-len</strong>, <strong>loop-top</strong>, and <strong>play-speed</strong>.
In the <strong>run-step</strong> function, we’ll use the <strong>curr-step</strong> counter and add it to <strong>loop-top</strong>
to get the index point of the seq-data. Then we will use the <strong>modulo</strong> function with
the length of the seq-data vector as an argument to wrap this index around
safely. For example, if our current step is 6, and loop top is 3, but our sequence
data is only 8 points long, using modulo will wrap the 9 around to be 1.</p>
<p>The examples below only show the changed code, but the entire code for this version is included at
the end.</p>
<div class="highlight-scm notranslate"><div class="highlight"><pre><span></span><span class="c1">; default loop-top and loop-len in steps</span>
<span class="p">(</span><span class="k">define </span><span class="nv">loop-len</span> <span class="mi">8</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="nv">loop-top</span> <span class="mi">0</span><span class="p">)</span>
<span class="c1">; rate, 2 means play twice as fast</span>
<span class="p">(</span><span class="k">define </span><span class="nv">play-speed</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1">; new play-note that adjusts duration for the playback rate</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">play-note</span> <span class="nv">params</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">post</span> <span class="s">&quot;(play-note)&quot;</span> <span class="nv">params</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">gate</span> <span class="p">(</span><span class="nf">params</span> <span class="mi">0</span><span class="p">))</span>
        <span class="c1">; scale duration according to play-speed</span>
        <span class="p">(</span><span class="nf">dur</span>  <span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="nb">/ </span><span class="mf">1.0</span> <span class="nv">play-speed</span><span class="p">)</span> <span class="p">(</span><span class="nf">params</span> <span class="mi">1</span><span class="p">)))</span>
        <span class="p">(</span><span class="nf">note</span> <span class="p">(</span><span class="nf">params</span> <span class="mi">2</span><span class="p">))</span>
        <span class="p">(</span><span class="nf">vel</span>  <span class="p">(</span><span class="nf">params</span> <span class="mi">3</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">if </span><span class="nv">gate</span>
      <span class="c1">; output in the format expected by Max makenote object</span>
      <span class="p">(</span><span class="nf">out</span> <span class="mi">0</span> <span class="p">(</span><span class="nb">list </span><span class="nv">note</span> <span class="nv">vel</span> <span class="nv">dur</span><span class="p">)))))</span>

<span class="c1">; new run-step, with loop-top, loop-len, and play-speed</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">run-step</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">post</span> <span class="s">&quot;(run-step)&quot;</span><span class="p">)</span>

  <span class="c1">; calculate the index using loop-settings</span>
  <span class="c1">; Note: need let* as we refer to index-unsafe for index</span>
  <span class="p">(</span><span class="k">let* </span><span class="p">((</span><span class="nf">index-unsafe</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">loop-top</span> <span class="nv">curr-step</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">step-index</span> <span class="p">(</span><span class="nb">modulo </span><span class="nv">index-unsafe</span> <span class="nv">num-steps</span><span class="p">)))</span>
    <span class="c1">; use our calculated index in the body of the let</span>
    <span class="p">(</span><span class="nf">play-note</span> <span class="p">(</span><span class="nf">seq-data</span> <span class="nv">step-index</span><span class="p">)))</span>

  <span class="c1">; making a one-liner for space, but functionally the same</span>
  <span class="p">(</span><span class="k">set! </span><span class="nv">curr-step</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt; </span><span class="nv">curr-step</span> <span class="p">(</span><span class="nb">- </span><span class="nv">loop-len</span> <span class="mi">1</span><span class="p">))</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="nv">curr-step</span><span class="p">)</span> <span class="mi">0</span><span class="p">))</span>

  <span class="c1">; schedule next step, using play-speed multiplier</span>
  <span class="p">(</span><span class="k">if </span><span class="nv">playing</span>
    <span class="p">(</span><span class="k">set! </span><span class="nv">cb-handle</span> <span class="p">(</span><span class="nf">delay-t</span> <span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="nb">/ </span><span class="mf">1.0</span> <span class="nv">play-speed</span><span class="p">)</span> <span class="nv">ticks-per-step</span><span class="p">)</span> <span class="nv">run-step</span><span class="p">)))</span>
</pre></div>
</div>
<p>If you load the step-seq-1-5.maxpat, you’ll see there are additional gui elements
for changing the play-speed, loop-top, and loop-len.</p>
<p>This is a good time for a warning about errors. In this version, our run-step
function <em>is</em> the function that schedules the next step. While this is convenient,
it also means that if run-step crashes, playback stops. In this case, we need to be careful that we
don’t pass a playback speed of 0, or we can get a divide-by-zero error, and the party
ends. We can protect against this with scheme, or in max. In this tutorial, I’ve
simply clamped the playback gui element to the range 0.25 to 2.0. In subsequent
tutorials we’ll look at other clocking approaches that remove this fragility so
that if you create an error situation, you don’t stop the sequencer. Another option
is to move the self-scheduling code to the top of run-step so that
playback will continue if run-step hits an error <em>after</em> that call. We won’t do
that in the tutorial code, as we want to catch errors in testing, but if we were
going to play this live, we’d likely want to. There are lots of options!</p>
</div>
<div class="section" id="step-6-a-simple-display">
<h2>Step 6 - A simple display<a class="headerlink" href="#step-6-a-simple-display" title="Permalink to this headline">¶</a></h2>
<p>The next thing we’ll do for this sequencer is add a very simple display to demonstrate
how you can build a GUI for whatever you want to see while the sequencer runs. For this
demo, we’ll update an LED object over each step so we visually see what step the sequencer
is on, and we’ll add updating our sliders to show the right value when a parameter is
set some other way (i.e. from the repl or another element).
We’re going to do this by giving 16 LED objects the scripting names ‘led-0’ to ‘led-15’,
and similarly, ‘slider-0’ to ‘slider-15’. (Pro-tip, when you have to do something like
this 16 times, you might want to edit your max patch in a text editor!)
This means we need to have sent s4m the <strong>scan</strong> message on initialization so that these
objects are registered. Then we’ll use the <strong>send</strong> function to sent the led and slider
objects their values.</p>
<div class="highlight-scm notranslate"><div class="highlight"><pre><span></span><span class="c1">; the last led index, in order to turn it off</span>
<span class="p">(</span><span class="k">define </span><span class="nv">last-led</span> <span class="mi">0</span><span class="p">)</span>

<span class="c1">; function to flash an led</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">flash-led</span> <span class="nv">step</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">last-led-id</span> <span class="p">(</span><span class="nf">symbol</span> <span class="p">(</span><span class="nb">string-append </span><span class="s">&quot;led-&quot;</span> <span class="p">(</span><span class="nb">number-&gt;string </span><span class="nv">last-led</span><span class="p">))))</span>
        <span class="p">(</span><span class="nf">this-led-id</span> <span class="p">(</span><span class="nf">symbol</span> <span class="p">(</span><span class="nb">string-append </span><span class="s">&quot;led-&quot;</span> <span class="p">(</span><span class="nb">number-&gt;string </span><span class="nv">step</span><span class="p">)))))</span>
    <span class="c1">; turn last-led off and this-led on</span>
    <span class="p">(</span><span class="nf">send</span> <span class="nv">last-led-id</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">send</span> <span class="nv">this-led-id</span> <span class="mi">1</span><span class="p">)))</span>

<span class="c1">; add sending to the slider to update-step-params</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">update-step-param</span> <span class="nv">step</span> <span class="nv">param</span> <span class="nv">value</span><span class="p">)</span>
  <span class="s">&quot;update one step and one paramater in the sequence data&quot;</span>
  <span class="p">(</span><span class="k">set! </span><span class="p">(</span><span class="nf">seq-data</span> <span class="nv">step</span> <span class="nv">param</span><span class="p">)</span> <span class="nv">value</span><span class="p">)</span>
  <span class="c1">; update the slider if this is a velocity message</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">param</span> <span class="mi">3</span><span class="p">)</span>
    <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">slider-id</span> <span class="p">(</span><span class="nf">symbol</span> <span class="p">(</span><span class="nb">string-append </span><span class="s">&quot;slider-&quot;</span> <span class="p">(</span><span class="nb">number-&gt;string </span><span class="nv">step</span><span class="p">)))))</span>
      <span class="p">(</span><span class="nf">send</span> <span class="nv">slider-id</span> <span class="ss">&#39;set</span> <span class="nv">value</span><span class="p">))))</span>
</pre></div>
</div>
<p>Now when we seed our data, the sliders jump into place. And if we update a step
through the repl, or any other GUI element that writes to the velocity param,
the corresponding slider updates.</p>
<p>A word of warning though: while this pattern works fine when we don’t have too many
gui elements, were we to make a very large gui (say a grid of many tracks by many steps by many bars),
it might require us to run with higher latency settings.
Updating a very large number of objects in one go puts a substantial load the scheduler, as we run a Scheme function
and put a message on the scheduler for every update. For a very large GUI, you
may want to pass the GUI update handling to a seperate s4m object in the low priority thread,
which will be the topic of a subsequent tutorial. At this scale, it’s not at all an issue.</p>
</div>
<div class="section" id="step-7-midi-input">
<h2>Step 7 - MIDI input<a class="headerlink" href="#step-7-midi-input" title="Permalink to this headline">¶</a></h2>
<p>The next step for our sequencer will be to add midi input for saving sequence data.
As everyone’s controllers are different, we’ll keep this simple, but it should give you
enough to go off to make more complex midi input systems easily. This is an area
where doing it in Scheme really shines.</p>
<p>We’ll have our input system do four things: users can select a step and set a duration
by using a number objects, and enter pitch and velocity by playing midi notes on channel 1.</p>
<p>We’ll start by adding two new variables: <strong>edit-step</strong> and <strong>edit-dur</strong>. These will
hold the currently selected step and duration. Playing a midi note will write the values
from the midi note number and velocity, along with the <strong>edit-dur</strong> to the step in <strong>edit-step</strong>.
This means that in Max nomenclature, the keyboard is <em>hot</em> - it triggers the work.</p>
<p>We’ll do this in Max by making two new number boxes, constraining their values reasonably
in the inspector, and hooking them up to messages boxes using the $ notation to call our
Scheme functions for selecting a step and dur, which we’ll call <strong>select-step</strong> and <strong>select-dur</strong>.</p>
<div class="highlight-scm notranslate"><div class="highlight"><pre><span></span><span class="c1">; new var for selected step and current dur</span>
<span class="p">(</span><span class="k">define </span><span class="nv">edit-step</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="nv">edit-dur</span> <span class="mi">0</span><span class="p">)</span>

<span class="c1">; new edit input functions</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">select-step</span> <span class="nv">step</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">post</span> <span class="s">&quot;editing step:&quot;</span> <span class="nv">step</span><span class="p">)</span>
  <span class="c1">; the GUI says 1-16 to match musician nomenaclature</span>
  <span class="c1">; but the computer representation wants index 0+</span>
  <span class="p">(</span><span class="k">set! </span><span class="nv">edit-step</span> <span class="p">(</span><span class="nb">- </span><span class="nv">step</span> <span class="mi">1</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">select-dur</span> <span class="nv">dur</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">post</span> <span class="s">&quot;duration selected:&quot;</span> <span class="nv">dur</span><span class="p">)</span>
  <span class="p">(</span><span class="k">set! </span><span class="nv">edit-dur</span> <span class="nv">dur</span><span class="p">))</span>
</pre></div>
</div>
<p>Next we’ll add a <strong>midi-note</strong> function. This will get called from Max with a message that we
want to look like <strong>midi-note {note} {vel} {chan}</strong>. We’ll do this by connecting a Max <strong>notein</strong>
to a  <strong>join</strong>, then to a <strong>prepend midi-note</strong> object, and finally sending to <strong>s4m</strong> inlet 0.
We can test this with a dummy midi-note function that outputs to the console.</p>
<p>Once that’s working, all that’s left is to make the midi-note function write to our sequence
data:</p>
<div class="highlight-scm notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">midi-note</span> <span class="nv">note-num</span> <span class="nv">vel</span> <span class="nv">channel</span><span class="p">)</span>
  <span class="s">&quot;handle midi-note input for update seq data&quot;</span>
  <span class="c1">; ignore midi-off messages (vel = 0) or not channel 1</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="k">and </span><span class="p">(</span><span class="nb">= </span><span class="mi">1</span> <span class="nv">channel</span><span class="p">)</span> <span class="p">(</span><span class="nb">&gt; </span><span class="nv">vel</span> <span class="mi">0</span><span class="p">))</span>
    <span class="p">(</span><span class="nf">begin</span>
      <span class="p">(</span><span class="nf">post</span> <span class="s">&quot;midi-note&quot;</span> <span class="nv">note-num</span> <span class="nv">vel</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">update-step</span> <span class="nv">edit-step</span> <span class="p">(</span><span class="nb">list </span><span class="mi">1</span> <span class="nv">edit-dur</span> <span class="nv">note-num</span> <span class="nv">vel</span><span class="p">)))))</span>
</pre></div>
</div>
<p>And that’s all there is to it! We can now edit our sequence in real time from the keyboard,
and you’ll see the velocity sliders updating every time we change a step as well. The same
pattern can be extended indefinitely for more complex midi input. In a subsequent tutorial
we’ll tackle real time midi input where we can play into the sequence, storing the duration
we play on the keyboard, but this involves significantly more complex code.</p>
</div>
<div class="section" id="step-8-multiple-tracks">
<h2>Step 8 - Multiple Tracks<a class="headerlink" href="#step-8-multiple-tracks" title="Permalink to this headline">¶</a></h2>
<p>We’ve saved multiple tracks until now as it’s a big one and adds quite a bit of code.
We have a couple of options : we can make one sequencer that plays multiple tracks, or we can make
multiple sequencers. In tutorial series 2, we’ll look at the second option, which requires
us to refactor our code so that we don’t have all our variables in the global namespace.
In this version, we’ll put multiple tracks into the same sequencer.</p>
<p>We want to be able to change loop settings separately for each track, so this means:</p>
<ul class="simple">
<li><p>One sequencer with one playback speed handles all tracks, so play-speed is global</p></li>
<li><p>The sequence data gets a third dimension for <strong>track</strong></p></li>
<li><p>Track specific settings need to become vectors with one point per track</p></li>
<li><p>We need to add track selection to all our reading and writing functions.</p></li>
<li><p>We’ll add track mutes to each track.</p></li>
<li><p>We need to loop through all tracks in <strong>run-step</strong></p></li>
</ul>
<p>To keep this manageable, we will not tackle multi-track display. I leave it as an exercise
for the reader to decide how you might want to handle that, and advanced options will
be covered in subsequent toolkit components. So for now, we’re just going to delete
the sliders and leds. We’ll work from the top to the bottom of the code, updating things
to be multiple tracks.</p>
<p>First up, variables. We will add a <strong>num-tracks</strong> var, and we’ll change the track
settings to vectors with <strong>num-tracks</strong> points. We’ll put in the new <strong>track-on</strong> vector
for track muting. Finally, we’ll add a new var, <strong>loop-sync</strong>, determining
when track loops resync, which will be explained later.</p>
<div class="highlight-scm notranslate"><div class="highlight"><pre><span></span><span class="c1">; globals that can stay the same</span>
<span class="p">(</span><span class="k">define </span><span class="nv">cb-handle</span> <span class="no">#f</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="nv">playing</span> <span class="no">#f</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="nv">ticks-per-step</span> <span class="mi">120</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="nv">play-speed</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1">; add a track selector for editing</span>
<span class="p">(</span><span class="k">define </span><span class="nv">edit-step</span>   <span class="mi">0</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="nv">edit-dur</span>    <span class="mi">0</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="nv">edit-track</span>  <span class="mi">0</span><span class="p">)</span>

<span class="c1">; add num-tracks</span>
<span class="p">(</span><span class="k">define </span><span class="nv">num-tracks</span> <span class="mi">4</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="nv">num-params</span> <span class="mi">4</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="nv">num-steps</span> <span class="mi">16</span><span class="p">)</span>

<span class="c1">; these are now vectors, num-tracks in size</span>
<span class="p">(</span><span class="k">define </span><span class="nv">loop-len</span>  <span class="p">(</span><span class="nb">make-vector </span><span class="nv">num-tracks</span> <span class="mi">16</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">loop-top</span>  <span class="p">(</span><span class="nb">make-vector </span><span class="nv">num-tracks</span> <span class="mi">0</span><span class="p">))</span>
<span class="c1">; add track mute, vector of 1 or 0</span>
<span class="p">(</span><span class="k">define </span><span class="nv">track-on</span>  <span class="p">(</span><span class="nb">make-vector </span><span class="nv">num-tracks</span> <span class="mi">1</span><span class="p">))</span>

<span class="c1">; curr-step is not a vector, it&#39;s the master step</span>
<span class="p">(</span><span class="k">define </span><span class="nv">curr-step</span> <span class="mi">0</span><span class="p">)</span>
<span class="c1">; number of steps after which track loops resync</span>
<span class="p">(</span><span class="k">define </span><span class="nv">loop-sync</span> <span class="mi">16</span><span class="p">)</span>

<span class="c1">; seq-data gets a third dimension, which will go first</span>
<span class="p">(</span><span class="k">define </span><span class="nv">seq-data</span> <span class="p">(</span><span class="nb">make-vector </span><span class="p">(</span><span class="nb">list </span><span class="nv">num-tracks</span> <span class="nv">num-steps</span> <span class="nv">num-params</span><span class="p">)</span> <span class="mi">0</span><span class="p">))</span>
<span class="c1">; now to get a vector of param values, we can do</span>
<span class="c1">; (seq-data track step)</span>
</pre></div>
</div>
<p>Updating midi input is simple, we add a selector for track, and we use this
as an argument to update-step, which we implement shortly:</p>
<div class="highlight-scm notranslate"><div class="highlight"><pre><span></span><span class="c1">; add a select track edit function</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">select-track</span> <span class="nv">track</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">post</span> <span class="s">&quot;editing track&quot;</span> <span class="nv">track</span><span class="p">)</span>
  <span class="p">(</span><span class="k">set! </span><span class="nv">edit-track</span> <span class="p">(</span><span class="nb">- </span><span class="nv">track</span> <span class="mi">1</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">select-step</span> <span class="nv">step</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">post</span> <span class="s">&quot;editing step&quot;</span> <span class="nv">step</span><span class="p">)</span>
  <span class="p">(</span><span class="k">set! </span><span class="nv">edit-step</span> <span class="p">(</span><span class="nb">- </span><span class="nv">step</span> <span class="mi">1</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">select-dur</span> <span class="nv">dur</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">post</span> <span class="s">&quot;duration selected:&quot;</span> <span class="nv">dur</span><span class="p">)</span>
  <span class="p">(</span><span class="k">set! </span><span class="nv">edit-dur</span> <span class="nv">dur</span><span class="p">))</span>

<span class="c1">; add new edit-track var in call to update-step</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">midi-note</span> <span class="nv">note-num</span> <span class="nv">vel</span> <span class="nv">channel</span><span class="p">)</span>
  <span class="s">&quot;handle midi-note input for update seq data&quot;</span>
  <span class="c1">; ignore midi-off messages (vel = 0) or not channel 1</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="k">and </span><span class="p">(</span><span class="nb">= </span><span class="mi">1</span> <span class="nv">channel</span><span class="p">)</span> <span class="p">(</span><span class="nb">&gt; </span><span class="nv">vel</span> <span class="mi">0</span><span class="p">))</span>
    <span class="p">(</span><span class="nf">begin</span>
      <span class="p">(</span><span class="nf">post</span> <span class="s">&quot;midi-note&quot;</span> <span class="nv">note-num</span> <span class="nv">vel</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">update-step</span> <span class="nv">edit-track</span> <span class="nv">edit-step</span> <span class="p">(</span><span class="nb">list </span><span class="mi">1</span> <span class="nv">edit-dur</span> <span class="nv">note-num</span> <span class="nv">vel</span><span class="p">)))))</span>
</pre></div>
</div>
<p>Time for the data editing functions. We’ll delete flash-led and the code for calling it
and for updating the velocity sliders. We need to add track parameters to our three data
entry functions. Thanks to the handy syntax of s7’s muli-dimensional vectors, this
is dead easy:</p>
<div class="highlight-scm notranslate"><div class="highlight"><pre><span></span><span class="c1">; adding track variables to these</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">update-step-param</span> <span class="nv">track</span> <span class="nv">step</span> <span class="nv">param</span> <span class="nv">value</span><span class="p">)</span>
  <span class="s">&quot;update one step and one paramater in the sequence data&quot;</span>
  <span class="p">(</span><span class="k">set! </span><span class="p">(</span><span class="nf">seq-data</span> <span class="nv">track</span> <span class="nv">step</span> <span class="nv">param</span><span class="p">)</span> <span class="nv">value</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">update-step</span> <span class="nv">track</span> <span class="nv">step</span> <span class="nv">pvals</span><span class="p">)</span>
  <span class="s">&quot;update all params for a step from a sequence of pvals&quot;</span>
  <span class="p">(</span><span class="nf">for-each</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">param</span> <span class="nv">value</span><span class="p">)(</span><span class="nf">update-step-param</span> <span class="nv">track</span> <span class="nv">step</span> <span class="nv">param</span> <span class="nv">value</span><span class="p">))</span>
    <span class="c1">; iterate through a sequence of integers and the pvals in parallel</span>
    <span class="p">(</span><span class="nf">range</span> <span class="mi">0</span> <span class="p">(</span><span class="nb">length </span><span class="nv">pvals</span><span class="p">))</span> <span class="nv">pvals</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">update-seq</span> <span class="nv">track</span> <span class="nv">starting-step</span> <span class="nv">pvals-list</span><span class="p">)</span>
  <span class="s">&quot;write multiple notes into the sequence data starting at starting-step&quot;</span>
  <span class="p">(</span><span class="nf">for-each</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">step</span> <span class="nv">pvals</span><span class="p">)</span> <span class="p">(</span><span class="nf">update-step</span> <span class="nv">track</span> <span class="nv">step</span> <span class="nv">pvals</span><span class="p">))</span>
    <span class="p">(</span><span class="nf">range</span> <span class="nv">starting-step</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">starting-step</span> <span class="p">(</span><span class="nb">length </span><span class="nv">pvals-list</span><span class="p">)))</span>
    <span class="nv">pvals-list</span><span class="p">))</span>
</pre></div>
</div>
<p>Next we need to decide how we’ll handle output. We could do one of two things:
add a track number to the list we output to Max and deal it there, or give
s4m an outlet for each track. We’ll go with an outlet for each track,
and we’ll add a track argument.</p>
<div class="highlight-scm notranslate"><div class="highlight"><pre><span></span><span class="c1">; add a track argument and map it to outlet</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">play-note</span> <span class="nv">track</span> <span class="nv">params</span><span class="p">)</span>
  <span class="c1">;(post &quot;(play-note)&quot; params)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">gate</span> <span class="p">(</span><span class="nf">params</span> <span class="mi">0</span><span class="p">))</span>
        <span class="c1">; scale duration according to play-speed</span>
        <span class="p">(</span><span class="nf">dur</span>  <span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="nb">/ </span><span class="mf">1.0</span> <span class="nv">play-speed</span><span class="p">)</span> <span class="p">(</span><span class="nf">params</span> <span class="mi">1</span><span class="p">)))</span>
        <span class="p">(</span><span class="nf">note</span> <span class="p">(</span><span class="nf">params</span> <span class="mi">2</span><span class="p">))</span>
        <span class="p">(</span><span class="nf">vel</span>  <span class="p">(</span><span class="nf">params</span> <span class="mi">3</span><span class="p">)))</span>
    <span class="c1">; notes only go out if the gate is on</span>
    <span class="p">(</span><span class="k">if </span><span class="nv">gate</span>
      <span class="p">(</span><span class="nf">out</span> <span class="nv">track</span> <span class="p">(</span><span class="nb">list </span><span class="nv">note</span> <span class="nv">vel</span> <span class="nv">dur</span><span class="p">)))))</span>
</pre></div>
</div>
<p>So far, this has pretty simple. Now we have the tricky business - <strong>run-step</strong>.
We need to discuss how track looping is going to work first.</p>
<p>Each of our tracks has their own loop-top and loop-len, requiring us to make some
decisions about how these free-wheel or sync. In this version we’re going
to use a resyncing strategy that I’ve personally found is a good balance of enabling
variety vs the ability to reset to “normal” when you need to.
If you want totally freewheeling track loops, it’s
probably better to use the separate-sequencer-per-track design that will be covered
in the second tutorial series.</p>
<p>The concept here is that there is a master loop-length and a master curr-step,
stored in our <strong>loop-sync</strong> and <strong>curr-step</strong> vars. In real world use, these
might be something like 8 or 16 bars of steps. A track loop-lenh <em>can’t be longer
than this value.</em>
Individual track index points are calculated using modulo arithmetic against this
master loop. This means that at any time, we can put the loop length for a track
back to a regular size (say 1, 2, 4, or 8 bars), and the step for that track will
jump immediately to the (new) right place. If our loop-len is irregular, when it
gets to the boundary for the loop-sync point, it will jump back to the zero index
at that point.</p>
<p>To illustrate: if <strong>loop-sync</strong> is 8, and <strong>loop-len</strong> for a track is 3, its index points
for 16 steps are going to go:</p>
<p><strong>0   1   2   0   1   2   0   1   0   1   2   0   1   2   0   1</strong></p>
<p>Calculating this is straightforward. Our curr-step counter now counts up to
loop-sync, making loop-sync act as length for a master loop. And our individual track index
is the curr-step modulo the loop-sync. This automatically makes every track loop resync
when the curr-step counter rolls-over to 0. Then we apply the loop-top shift to that
result.</p>
<p>To make this a bit easier to read, we’ll put this logic into a helper function, <strong>get-track-step-data</strong>.
In <strong>run-step</strong> we need to loop over each track, and we’ll check the track mute there:</p>
<div class="highlight-scm notranslate"><div class="highlight"><pre><span></span><span class="c1">; new run-step helper that works with track loop points</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">get-track-step-data</span> <span class="nv">track</span> <span class="nv">master-step</span><span class="p">)</span>
  <span class="s">&quot;return a vector of param vals for a given track and master step&quot;</span>
  <span class="c1">; get the step for this track calculating from track&#39;s loop-top and loop-len</span>
  <span class="c1">; note that master-step already rolls over automatically at loop-sync steps</span>
  <span class="p">(</span><span class="k">let* </span><span class="p">((</span><span class="nf">t-loop-len</span> <span class="p">(</span><span class="nf">loop-len</span> <span class="nv">track</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">t-loop-top</span> <span class="p">(</span><span class="nf">loop-top</span> <span class="nv">track</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">actual-step</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">t-loop-top</span> <span class="p">(</span><span class="nb">modulo </span><span class="nv">master-step</span> <span class="nv">t-loop-len</span><span class="p">))))</span>
    <span class="p">(</span><span class="nf">seq-data</span> <span class="nv">track</span> <span class="nv">actual-step</span><span class="p">)))</span>

<span class="c1">; update run-step for separate track looping</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">run-step</span><span class="p">)</span>
  <span class="c1">;(post &quot;(run-step)&quot;)</span>
  <span class="c1">; for each track, get step data and pass to output function</span>
  <span class="p">(</span><span class="nf">for-each</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">track-num</span><span class="p">)</span>
      <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">step-params</span> <span class="p">(</span><span class="nf">get-track-step-data</span> <span class="nv">track-num</span> <span class="nv">curr-step</span><span class="p">)))</span>
        <span class="c1">; only ouput it track not muted</span>
        <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="mi">1</span> <span class="p">(</span><span class="nf">track-on</span> <span class="nv">track-num</span><span class="p">))</span>
          <span class="p">(</span><span class="nf">play-note</span> <span class="nv">track-num</span> <span class="nv">step-params</span><span class="p">))))</span>
    <span class="c1">; what we iterate over</span>
    <span class="p">(</span><span class="nf">range</span> <span class="mi">0</span> <span class="nv">num-tracks</span><span class="p">))</span>

  <span class="c1">; change curr-step to use loop-sync as its roll-over point</span>
  <span class="p">(</span><span class="k">set! </span><span class="nv">curr-step</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt; </span><span class="nv">curr-step</span> <span class="p">(</span><span class="nb">- </span><span class="nv">loop-sync</span> <span class="mi">1</span><span class="p">))</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="nv">curr-step</span><span class="p">)</span> <span class="mi">0</span><span class="p">))</span>
  <span class="c1">; schedule next step, using play-speed multiplier</span>
  <span class="p">(</span><span class="k">if </span><span class="nv">playing</span>
    <span class="p">(</span><span class="k">set! </span><span class="nv">cb-handle</span> <span class="p">(</span><span class="nf">delay-t</span> <span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="nb">/ </span><span class="mf">1.0</span> <span class="nv">play-speed</span><span class="p">)</span> <span class="nv">ticks-per-step</span><span class="p">)</span> <span class="nv">run-step</span><span class="p">)))</span>
<span class="p">)</span><span class="c1">; end run-step</span>
</pre></div>
</div>
<p>The one remaining piece for multi-track playback is how we will update the
track specific  controls. By virtue of the how the loop calculation works,
we can’t have track loop lengths be longer than the master loop sync control.
However, the modulo math means that we don’t really need to protect against this, we’ll
just never get there - the step counter will roll over at the loop-sync point.
For illustration purposes, we’ll put some error handling in.</p>
<p>In the Max patch, we’ll add loop controls for 4 tracks, with boxes for
loop-len and loop-top, and a toggle for track muting.</p>
<div class="highlight-scm notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">set-loop-len</span> <span class="nv">track</span> <span class="nv">steps</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">post</span> <span class="s">&quot;set-loop-len&quot;</span> <span class="nv">track</span> <span class="nv">steps</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&gt; </span><span class="nv">steps</span> <span class="nv">loop-sync</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">post</span> <span class="s">&quot;ERROR: loop length cannot exceed loop-sync, at:&quot;</span> <span class="nv">loop-sync</span><span class="p">)</span>
    <span class="c1">; else set the value</span>
    <span class="p">(</span><span class="k">set! </span><span class="p">(</span><span class="nf">loop-len</span> <span class="nv">track</span><span class="p">)</span> <span class="nv">steps</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">set-loop-top</span> <span class="nv">track</span> <span class="nv">steps</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">post</span> <span class="s">&quot;set-loop-top&quot;</span> <span class="nv">track</span> <span class="nv">steps</span><span class="p">)</span>
  <span class="p">(</span><span class="k">set! </span><span class="p">(</span><span class="nf">loop-top</span> <span class="nv">track</span><span class="p">)</span> <span class="nv">steps</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">set-track-on</span> <span class="nv">track</span> <span class="nv">enabled</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">post</span> <span class="s">&quot;set-track-on&quot;</span> <span class="nv">track</span> <span class="nv">enabled</span><span class="p">)</span>
  <span class="p">(</span><span class="k">set! </span><span class="p">(</span><span class="nf">track-on</span> <span class="nv">track</span><span class="p">)</span> <span class="nv">enabled</span><span class="p">))</span>
</pre></div>
</div>
<p>In the sample Max patch, there are number boxes for editing, and <strong>loadmess</strong>
objects to start them off with reasonable values. In a more full featured version,
we’d want to make an <strong>init</strong> function that sends messages to our GUI objects
to set them with the correct starting values so that these are always set <em>from
the Scheme data</em>. As the changes in this version are already quite complex, we’ll
look at that approach in a subsequent tutorial when we do saving and loading of data.</p>
</div>
<div class="section" id="wrapping-up-and-next-steps">
<h2>Wrapping up and next steps<a class="headerlink" href="#wrapping-up-and-next-steps" title="Permalink to this headline">¶</a></h2>
<p>Our sequencer is fully functional, but there are a few areas we might want to improve
and will cover in subsequent tutorials.  All our code is global. This is useful when
prototyping, because we can redefine
any function or variable, even while the sequencer is playing. However, this prevents
us from making more than one instance of our sequencer. If we want to have multiple
sequencers, perhaps for exploring poly-rhythmic music, we need a way to contain
all our code. This will be covered in Tutorial 2.</p>
<p>Some of the other topics for subsequent tutorials include:</p>
<ul class="simple">
<li><p>Adding and sequencing Scheme functions for algorithmic and stochastic processes</p></li>
<li><p>Orchestrating multiple sequencers with a score sequencer</p></li>
<li><p>Hooking up midi controllers to update our sequence data from hardware</p></li>
<li><p>Saving and loading sets to disk</p></li>
<li><p>Building sophisticated displays to see our sequence data on screen</p></li>
</ul>
<p>I hope you enjoy building sequencers with the toolkit, and please get in touch
with feedback, requests, or issues!</p>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Scheme for Max Sequencing Toolkit</a></h1>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="tutorials-intro.html">Introduction</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Tutorial 1 - Multi-Track Step Sequencer</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#step-1-clocking-options">Step 1 - Clocking options</a></li>
<li class="toctree-l2"><a class="reference internal" href="#step-2-transport-controls">Step 2 - Transport controls</a></li>
<li class="toctree-l2"><a class="reference internal" href="#step-3-musical-data-and-output">Step 3 - Musical data and output</a></li>
<li class="toctree-l2"><a class="reference internal" href="#step-4-multi-dimensional-data-and-writing-to-data">Step 4 - Multi-dimensional data, and writing to data</a></li>
<li class="toctree-l2"><a class="reference internal" href="#step-5-loop-controls">Step 5 - Loop controls</a></li>
<li class="toctree-l2"><a class="reference internal" href="#step-6-a-simple-display">Step 6 - A simple display</a></li>
<li class="toctree-l2"><a class="reference internal" href="#step-7-midi-input">Step 7 - MIDI input</a></li>
<li class="toctree-l2"><a class="reference internal" href="#step-8-multiple-tracks">Step 8 - Multiple Tracks</a></li>
<li class="toctree-l2"><a class="reference internal" href="#wrapping-up-and-next-steps">Wrapping up and next steps</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="performance.html">Appendix: Performance, timing accuracy, and Max settings</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="tutorials-intro.html" title="previous chapter">Introduction</a></li>
      <li>Next: <a href="performance.html" title="next chapter">Appendix: Performance, timing accuracy, and Max settings</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2021, Iain C. T. Duncan.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.5.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/step-sequencer-tut-1.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>